
#include <string.h>
#include <avr/pgmspace.h>
#include "aes.h"

typedef unsigned char byte;


#ifdef AES_USEASM
	#define GF28_MUL2(a) { asm ("lsl %0 \n brcc .+2 \n eor %0, %1 \n" : "=r" (a) : "r" (c0x1b), "0" (a)); }
	#define GF28_DIV2(a) { asm ("lsr %0 \n brcc .+2 \n eor %0, %1 \n" : "=r" (a) : "r" (c0x8d), "0" (a)); }
#else
	#define GF28_MUL2(a) { if (a&0x80) { a = (a<<1) ^ 0x1b; } else { a <<= 1; } }
	#define GF28_DIV2(a) { if (a&0x01) { a = (a>>1) ^ 0x8d; } else { a >>= 1; } }
#endif


#ifdef AES_CIPHER
	#define DIRECT 1 
#else
	#define DIRECT 0
#endif


#ifdef AES_SWSBOX
	#define SBOXTYPE 2  // funkcja
#else
	#define SBOXTYPE 1  // tablica
#endif


#ifdef AES_INVCIPHER
	#define INV 1 
	#ifdef AES_SWINVSBOX
		#define INVSBOXTYPE 2  // funkcja
	#else
		#define INVSBOXTYPE 1  // tablica
	#endif
#else
	#define INV 0
	#define INVSBOXTYPE 0      // brak
#endif


#if SBOXTYPE==1
	static const byte Sbox[] PROGMEM = {
		0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
		0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
		0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
		0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
		0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
		0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
		0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
		0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
		0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
		0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
		0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
		0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
		0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
		0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
		0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
		0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
	};
	#define SBOX(x) (pgm_read_byte(Sbox+(x)))
#endif


#if INVSBOXTYPE==1
	static const byte InvSbox[] PROGMEM = {
		0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
		0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
		0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
		0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
		0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
		0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
		0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
		0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
		0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
		0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
		0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
		0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
		0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
		0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
		0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
		0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
	};
	#define INVSBOX(x) (pgm_read_byte(InvSbox+(x)))
#endif


#if SBOXTYPE==2 && INVSBOXTYPE==2
	#define SBOX(x) (swSbox((x),0))
	#define INVSBOX(x) (swSbox((x),1))
#else
	#if SBOXTYPE==2
		#define SBOX(x) (swSbox(x))
	#endif
	#if INVSBOXTYPE==2
		#define INVSBOX(x) (swSbox(x))
	#endif
#endif


#if SBOXTYPE==2 || INVSBOXTYPE==2



#if SBOXTYPE==2 && INVSBOXTYPE==2
static byte swSbox(byte x, byte inv)
#else
static byte swSbox(byte x)
#endif
{
#if SBOXTYPE!=2 || INVSBOXTYPE!=2
	#if SBOXTYPE==2
		byte inv = 0;
	#endif
	#if INVSBOXTYPE==2
		byte inv = 1;
	#endif
#endif
	byte c0x1b = 0x1b;
	byte q, r3, a3, i, a, b, c, n;
	byte r1hi = 1;
	byte r1 = 0x1b;
	byte r2 = x;
	byte a1 = 0;
	byte a2 = 1;

	if (inv) {
		r2 ^= 0x63;
		a = 0;
		b = 0x4a;
		while (r2) {
			if (r2&1) a ^= b;
			#ifdef AES_USEASM
			asm ("lsl %0 \n brcc .+2 \n ori %0, 1" : "=r" (b) : "0" (b));
			#else
			b = (b<<1) | (b>>7);
			#endif
			r2 >>= 1;
		}
		r2 = a;
	}

	if (r2==0) a2 = a1;

	while (r2 > 1) {
		// r3 = r1 % r2
		// q = r1 / r2

		// a = a % b;
		// c = a / b;
		a = r1;
		b = r2;
		c = 0;
		n = 1;
		while (!(b&0x80)) {
			b <<= 1;
			n++;
		}
		if (r1hi) {
			r1hi = 0;
			a ^= b << 1;
			c = 1;
		}
		for (i=n; i!=0; i--) {
			c <<= 1;
			if (a & 0x80) {
				c |= 1;
				a ^= b;
			}
			a <<= 1;
		}
		r3 = a>>n;
		q = c;

		// a3 = q * a2 + a1
		a3 = a1;
		a = a2;
		while (q) {
			if (q&1) a3 ^= a;
			GF28_MUL2(a);
			q >>= 1;
		}

		// next step
		a1 = a2;
		a2 = a3;
		r1 = r2;
		r2 = r3;

	}
	// x^-1 = a2

	if (!inv) {
		a = 0x63;
		b = 0x1f;
		while (a2) {
			if (a2&1) a ^= b;
			#ifdef AES_USEASM
			asm ("lsl %0 \n brcc .+2 \n ori %0, 1" : "=r" (b) : "0" (b));
			#else
			b = (b<<1) | (b>>7);
			#endif
			a2 >>= 1;
		}
		return a;
	} else {
		return a2;
	}
}

#endif //SBOXTYPE==2 || INVSBOXTYPE==2


unsigned char aesKey[16];

static byte tempKey[16];

static byte Rcon;


static void aesAddRoundKey(byte* state)
{
	byte c0x1b = 0x1b;
	byte *ptr;
	byte a, b, c, d, t, i;
	for (i = 0; i < 16; i+=4) {
		ptr = tempKey + ((i-4)&12);
		a = ptr[0];
		b = ptr[1];
		c = ptr[2];
		d = ptr[3];
		if (i == 0) {
			t = b;
			b = SBOX(c);
			c = SBOX(d);
			d = SBOX(a);
			a = SBOX(t) ^ Rcon;
			GF28_MUL2(Rcon);
		}
		ptr = tempKey + i;
		#if INV
			t = ptr[0]; ptr[0] = a ^ t; a = t;
			t = ptr[1]; ptr[1] = b ^ t; b = t;
			t = ptr[2]; ptr[2] = c ^ t; c = t;
			t = ptr[3]; ptr[3] = d ^ t; d = t;
			if (state) {
				*state++ ^= a;
				*state++ ^= b;
				*state++ ^= c;
				*state++ ^= d;
			}
		#else
			t = ptr[0]; *state++ ^= t; ptr[0] = a ^ t;
			t = ptr[1]; *state++ ^= t; ptr[1] = b ^ t;
			t = ptr[2]; *state++ ^= t; ptr[2] = c ^ t;
			t = ptr[3]; *state++ ^= t; ptr[3] = d ^ t;
		#endif
	}
}

#if INV

static void aesInvAddRoundKey(byte* state)
{
	byte c0x8d = 0x8d;
	byte *ptr;
	byte a, b, c, d, t, i;
	for (i = 12; !(i&0x80); i-=4) {
		ptr = tempKey + ((i-4)&12);
		a = ptr[0];
		b = ptr[1];
		c = ptr[2];
		d = ptr[3];
		if (i == 0) {
			GF28_DIV2(Rcon);
			t = a;
			a = SBOX(b) ^ Rcon;
			b = SBOX(c);
			c = SBOX(d);
			d = SBOX(t);
		}
		ptr = tempKey + i;
		a ^= ptr[0]; ptr[0] = a;
		b ^= ptr[1]; ptr[1] = b;
		c ^= ptr[2]; ptr[2] = c;
		d ^= ptr[3]; ptr[3] = d;
		ptr = state + i;
		ptr[0] ^= a;
		ptr[1] ^= b;
		ptr[2] ^= c;
		ptr[3] ^= d;
	}
	
}

#endif


#if DIRECT
static void aesSubBytes(byte* state)
{
	byte i;
	for (i=0; i<16; i++) {
		*state = SBOX(*state);
		state++;
	}
}
#endif

#if INV
static void aesInvSubBytes(byte* state)
{
	byte i;
	for (i=0; i<16; i++) {
		*state = INVSBOX(*state);
		state++;
	}
}
#endif


#if DIRECT && INV

#define aesShiftRows(s) aesShiftRows_B((s),0)
#define aesInvShiftRows(s) aesShiftRows_B((s),1)

static void aesShiftRows_B(byte* state, byte inv)

#else

#if DIRECT

static void aesShiftRows(byte* state)

#else

static void aesInvShiftRows(byte* state)

#endif

#endif
{
	#if !DIRECT || !INV
		#if DIRECT
			byte inv = 0;
		#else
			byte inv = 1;
		#endif
	#endif
	byte *ptr;
	byte i, j, k, t;
	for (i=1; i<4; i++) {
		for (j=i; j<4; j++) {
			ptr = state + j;
			if (inv) ptr += 8;
			for (k=j; k<12; k+=4) {
				t = ptr[0];
				ptr[0] = ptr[4];
				ptr[4] = t;
				if (inv) {
					ptr -= 4;
				} else {
					ptr += 4;
				}
			}
		}
	}
}

#if DIRECT
static void aesMixColumns(byte* state)
{
	byte c0x1b = 0x1b;
	byte i, *ptr;
	byte a0,a1,a2,a3,b0,b1,b2,b3;
	for (i=0; i<16; i+=4) {
		ptr = state + i;
		b0 = a0 = *ptr++;
		b1 = a1 = *ptr++;
		b2 = a2 = *ptr++;
		b3 = a3 = *ptr++;
		ptr = state + i;
		GF28_MUL2(b1);
		GF28_MUL2(b0);
	    *ptr++ = b0 ^ a1 ^ b1 ^ a2 ^ a3; // 2*a0 + 3*a1 + a2 + a3
		GF28_MUL2(b2);
	    *ptr++ = a0 ^ b1 ^ a2 ^ b2 ^ a3; // a0 * 2*a1 + 3*a2 + a3
		GF28_MUL2(b3);
	    *ptr++ = a0 ^ a1 ^ b2 ^ a3 ^ b3; // a0 + a1 + 2*a2 + 3*a3
	    *ptr++ = a0 ^ b0 ^ a1 ^ a2 ^ b3; // 3*a0 + a1 + a2 + 2*a3
	}
}
#endif

#if INV

static byte aesMulGF28(byte a, byte b)
{
	byte c0x1b = 0x1b;	
	byte r = 0;
	while (a) {
		if (a&1) r ^= b;
		a >>= 1;
		GF28_MUL2(b);
	}
	return r;
}

static byte aesInvMC_m[] = { 0xe, 0xb, 0xd, 0x9 };
static byte aesInvMC_c[4];

static void aesInvMixColumns(byte* state)
{
	byte t, i, j, k;
	byte a, b, c, d;
	for (i=0; i<16; i+=4) {
		for (j=0; j<4; j++) {
			t = 0;
			for (k=0; k<4; k++) {
				t ^= aesMulGF28(aesInvMC_m[k], state[i+k]);
			}
			aesInvMC_c[j] = t;
			t = aesInvMC_m[3];
			aesInvMC_m[3] = aesInvMC_m[2];
			aesInvMC_m[2] = aesInvMC_m[1];
			aesInvMC_m[1] = aesInvMC_m[0];
			aesInvMC_m[0] = t;
		}
		for (j=0; j<4; j++) {
			state[i+j] = aesInvMC_c[j];
		}
	}
}
#endif

#if DIRECT
void aesCipher(unsigned char* state)
{
	byte r;

	Rcon = 1;
	memcpy(tempKey, aesKey, 16);

	for (r = 0; r < 11; r++) {
		if (r) {
			aesSubBytes(state);
			aesShiftRows(state);
			if (r != 10) aesMixColumns(state);
		}
		aesAddRoundKey(state);
	}

}
#endif

#if INV
void aesInvCipher(unsigned char* state)
{
	byte r;

	Rcon = 1;
	memcpy(tempKey, aesKey, 16);
	for (r = 0; r < 11; r++) {
		aesAddRoundKey(0);
	}

	for (r = 10; !(r&0x80); r--) {
		aesInvAddRoundKey(state);
		if (r) {
			if (r != 10) aesInvMixColumns(state);
			aesInvShiftRows(state);
			aesInvSubBytes(state);
		}

	}

}
#endif

